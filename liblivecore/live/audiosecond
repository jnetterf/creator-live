/*******************************************************

    Part of the Creator Live Music Production Suite.
Copyright (C) Joshua Netterfield <joshua@nettek.ca> 2012

                  All rights reserved.

*******************************************************/

#ifndef AUDIOSECOND_H
#define AUDIOSECOND_H

#include <live/audio>
#include <live/audiograph>
#include <live/object>
#include <QReadWriteLock>
#include <QtConcurrentRun>

namespace live {

class LIBLIVECORESHARED_EXPORT AudioSecond
{
       /*SAMPLE RATE->VERIFY->003*/
    quint32 s_sampleOffset;     /*004*/
    float* s_data;          /*005*/
    QMap<long, AudioGraph*> s_graphs; /*???*/
public:
    friend class AudioContainer;
    AudioSecond(quint32 cbegin)
      : s_sampleOffset(cbegin)
      , s_data(new float[live::audio::sampleRate()])
      , s_graphs()
      { for(int i=0;i<live::audio::sampleRate();i++)
        {
            s_data[i]=0.0f;
        }
    }
    ~AudioSecond() { delete[]s_data; }

    inline float& operator[](const int&sample)
    {
        return s_data[sample-s_sampleOffset];
    }

    void newGraph(const long& boxSize)
    {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            if ((*it)->size() == boxSize) {
                (*it)->incrRef();
                return;
            }
        }
        AudioGraph* g = new AudioGraph(this, boxSize);
        s_graphs.insert(boxSize,g);
    }

    inline void deleteGraph(const long& boxSize)
    {
        AudioGraph* g = s_graphs.value(boxSize);
        Q_ASSERT(g);
        if (!g) return;

        if (g->decrRef()) {
            s_graphs.remove(boxSize);
            delete g;
        }
    }

    void updateGraph(const long& frame) {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->updateBoxWithFrame(frame);
        }
    }

    void pointGraph(const long& frame) {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->setPos(frame);
        }
    }

    long framesRemainingInGraph() {
        if (!s_graphs.size()) return 0;
        return live::audio::sampleRate() - s_graphs.begin().value()->pos();
    }

    void appendGraph(const long& frames) {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->append(frames);
        }
    }

    static AudioSecond* load(const QByteArray&);
    QByteArray save();

private:
    AudioSecond(const AudioSecond&)
      : s_sampleOffset(0)
      , s_data()
      , s_graphs()
      { TCRASH();
    }
    AudioSecond& operator=(const AudioSecond&) {
        TCRASH();
        return *this;
    }
};

class LIBLIVECORESHARED_EXPORT AudioContainer
{
protected:
    float zero;                 /*N/A*/
    quint32 sampleRate;     /*VERIFY->003*/
    QList<AudioSecond*> s_data; /*004*/
    quint32 s_dataSize;             /*004*/
    QReadWriteLock s_readLock;          /*N/A*/
    QMap<long, int> s_graphs; /* length -> refCount */
    int s_graphPointingTo;
public:
    friend class AudioTrack;
    AudioContainer()
      : zero(0.0f)
      , sampleRate(live::audio::sampleRate())
      , s_data()
      , s_dataSize(0)
      , s_readLock(QReadWriteLock::NonRecursive)
      , s_graphs()
      , s_graphPointingTo(-1)
      {
    }

    void newGraph(long size) {
        if (++s_graphs[size] == 1) {
            for (int i = 0; i < s_data.size(); ++i) {
                s_data[i]->newGraph(size);
            }
        }
    }

    void regSecond(AudioSecond* s) {
        for (QMap<long, int>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            for (int i = 0; i < it.value(); ++i) {
                s->newGraph(it.key());
            }
        }
    }

    void pointGraph(long frame) {
        if (int(frame/sampleRate) < s_data.size()) {
            s_graphPointingTo = (int)(frame/sampleRate);
            s_data[s_graphPointingTo]->pointGraph(frame%sampleRate);
        }
    }

    void appendGraph(long frames) {
        while (s_graphPointingTo != -1) {
            s_data[s_graphPointingTo]->appendGraph(qMin(frames, s_data[s_graphPointingTo]->framesRemainingInGraph()));
            frames -= s_data[s_graphPointingTo]->framesRemainingInGraph();
            if (frames >= 0) {
                if (s_graphPointingTo + 1 < s_data.size())
                    ++s_graphPointingTo;
                else {
                    s_graphPointingTo = -1;
                    return;
                }
            } else {
                return;
            }
        }
    }

    ~AudioContainer()
    {
        clear(1);
        s_dataSize=0;
    }

    void setData(const quint32&frame,const float&data)
    {
        lthread::audio();
        if(data == zero)
        {
            return;
        }

        for(quint32 i=s_data.size()-1;i<=frame/sampleRate;i++)
        {
            s_data.push_back(0);
            s_dataSize=s_data.size();
        }

        if(!s_data[(int)(frame/sampleRate)])
        {
            s_data[(int)(frame/sampleRate)]=new AudioSecond((frame/sampleRate)*sampleRate);
            regSecond(s_data[(int)(frame/sampleRate)]);
        }

        (*s_data[(int)(frame/sampleRate)])[(int)frame]=data;
        (*s_data[(int)(frame/sampleRate)]).updateGraph(frame);
    }

    const float& getData(const int&frame)
    {
        if(s_dataSize<=frame/sampleRate||!s_data[(int)(frame/sampleRate)])
        {
            return zero;
        }
        else
        {
            return (*s_data[(int)(frame/sampleRate)])[frame];
        }
    }

    //The return is the count of data returned through "data". There may be more
    //if called for the next frame.
    //By default, if no data exists(i.e., it is all null), data will be returned as
    //a null pointer. If instead, data should be created, forceCreation should be true.
    //Remember to set the graph position, and to append graph after use.
    int getRawPointer(const quint32&frame,float*& data,bool forceCreation=0, bool* warning = 0, bool enforceAudio = 1)
    {
        if (enforceAudio)
            lthread::audio();
        sampleRate=audio::sampleRate();
        if((s_dataSize<=frame/sampleRate||!s_data[(int)frame/sampleRate])&&!forceCreation)
        {
            data=0;
            return (int)((frame/sampleRate)*sampleRate+sampleRate-frame);
        }
        else if(s_dataSize<=frame/sampleRate)
        {
            for(long i=s_data.size()-1;i<=(long)frame/(long)sampleRate;i++)
            {
                s_data.push_back(0);
                s_dataSize=s_data.size();
            }
        }

        if(!s_data[(int)frame/sampleRate]) {
            s_data[(int)(frame/sampleRate)]=new AudioSecond((frame/sampleRate)*sampleRate);
            regSecond(s_data[(int)(frame/sampleRate)]);
        }

        if (warning) {
            *warning = (static_cast<unsigned>(s_data.size()) <= static_cast<unsigned>(frame/sampleRate + 1) || !s_data[(int) frame/sampleRate + 1]);
            // the goal of warning is to force creation of next frame in a non-RT thread.
        }

        int id=(int)(frame/sampleRate);
        data=&s_data[id]->s_data[frame-s_data[id]->s_sampleOffset];
        return (int)(s_data[id]->s_sampleOffset+sampleRate-frame);
    }

    int getConstPointer(const quint32&frame,const float*& data) const
    {
        return const_cast<AudioContainer*>(this)->getRawPointer(frame, const_cast<float*&>(data), false, 0, false);
    }

    class AudioDataDestroyer {
    public:
        AudioSecond* s_s;
        QReadWriteLock* s_l;
        AudioDataDestroyer(AudioSecond* s, QReadWriteLock* l) : s_s(s), s_l(l) {}
        void run() { if(s_l) s_l->lockForWrite(); delete s_s; if(s_l) s_l->unlock(); }
    };

    void clear(bool dying=0)
    {
        if(!s_readLock.tryLockForWrite()&&!dying) {
            QtConcurrent::run(this,&AudioContainer::clear,0);
            return;
        }
        s_dataSize=0;
        while (s_data.size())
        {
            AudioDataDestroyer* add = new AudioDataDestroyer(s_data.takeFirst(),(dying?0:&s_readLock));
            QtConcurrent::run(add,&AudioDataDestroyer::run);
        }
        if(!dying) {
            s_readLock.unlock();
        }
    }

    float length() const
    {
        float ret = (float) s_data.size();
        int i;
        for(i = audio::sampleRate() - 1;i >= 0; --i) {
            if (s_data.back()->s_data[i]!=0.0f) break; // FIXME
        }
        ret -= float(audio::sampleRate() - i)/float(audio::sampleRate());
        return ret;
    }

    void lock() {
        s_readLock.lockForRead();
    }

    void unlock() {
        s_readLock.unlock();
    }

    static AudioContainer* load(const QByteArray&);
    QByteArray save();
};

}

#endif // AUDIOSECOND_H
