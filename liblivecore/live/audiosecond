/*******************************************************

    Part of the Creator Live Music Production Suite.
Copyright (C) Joshua Netterfield <joshua@nettek.ca> 2012

                  All rights reserved.

*******************************************************/

#ifndef AUDIOSECOND_H
#define AUDIOSECOND_H

#include <live/audio>
#include <live/audiograph>
#include <live/object>
#include <QCoreApplication>
#include <QReadWriteLock>
#include <QTimer>

namespace live {

class LIBLIVECORESHARED_EXPORT AudioSecond
{
       /*SAMPLE RATE->VERIFY->003*/
    quint32 s_sampleOffset;     /*004*/
    float* s_data;          /*005*/
    QMap<long, AudioGraph*> s_graphs; /*???*/
public:
    friend class AudioContainer;
    friend class AudioGraph;

    AudioSecond(quint32 cbegin)
      : s_sampleOffset(cbegin)
      , s_data(new float[live::audio::sampleRate()])
      , s_graphs()
      { for(int i=0;i<live::audio::sampleRate();i++)
        {
            s_data[i]=0.0f;
        }
    }
    ~AudioSecond() { delete[]s_data; }

    inline float& operator[](const int&sample)
    {
        return s_data[sample-s_sampleOffset];
    }

    void newGraph(const long& boxSize)
    {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            if ((*it)->size() == boxSize) {
                (*it)->incrRef();
                return;
            }
        }
        AudioGraph* g = new AudioGraph(this, boxSize);
        if (!live::lthread::isAudio()) {
            g->setPos(0);
            g->append(live::audio::sampleRate()-1);
        }

        kill_kitten s_graphs.insert(boxSize,g);
    }

    inline void deleteGraph(const long& boxSize)
    {
        AudioGraph* g = s_graphs.value(boxSize);
        Q_ASSERT(g);
        if (!g) return;

        if (g->decrRef()) {
            s_graphs.remove(boxSize);
            delete g;
        }
    }

    void updateGraph(const long& frame) {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->updateBoxWithFrame(frame);
        }
    }

    void pointGraph(const long& frame) {
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->setPos(frame);
        }
    }

    long framesRemainingInGraph() {
        if (!s_graphs.size()) return 0;
        return live::audio::sampleRate() - s_graphs.begin().value()->pos();
    }

    void appendGraph(const long& frames) {
        if (frames <= 0 ) return;
        for (QMap<long, AudioGraph*>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            it.value()->append(frames);
        }
    }

    AudioGraph* graphForFrames(const long& frames) {
        return s_graphs.value(frames, 0);
    }

    static AudioSecond* load(const QByteArray&);
    QByteArray save();

    void setSampleOffset(int offset) {
        s_sampleOffset = offset;
    }

private:
    AudioSecond(const AudioSecond&)
      : s_sampleOffset(0)
      , s_data()
      , s_graphs()
      { TCRASH();
    }
    AudioSecond& operator=(const AudioSecond&) {
        TCRASH();
        return *this;
    }
};

class AudioSecondBank : public QObject
{
    Q_OBJECT
    QList<AudioSecond*> m_identity;
    QTimer t;
    QMutex x;

public:
    AudioSecond* buySecond(int offset) {
        AudioSecond* ret;
        x.lock();
        if (!m_identity.size()) {
            qCritical("No seconds to buy!");
            m_identity.push_back(new AudioSecond(offset));
        }
        ret = m_identity.takeFirst();
        x.unlock();
        ret->setSampleOffset(offset);
        QMetaObject::invokeMethod(&t,"start",Qt::QueuedConnection, Q_ARG(int,0));
        return ret;
    }

    friend class AudioContainer;

public:
    static AudioSecondBank* singleton;

    AudioSecondBank()
      : m_identity()
      , t(0)
    {
        t.setSingleShot(false);
        connect(&t, SIGNAL(timeout()), this, SLOT(allocSecond()));
        allocSecond();
    }
public slots:
    void allocSecond() {
        t.stop();
        while (m_identity.size() < 200) {
            AudioSecond* s = new AudioSecond(-1);
            x.lock();
            m_identity.push_back(s);
            x.unlock();
        }
    }
};

class LIBLIVECORESHARED_EXPORT AudioContainer
{
protected:
    float zero;                 /*N/A*/
    quint32 sampleRate;     /*VERIFY->003*/
    QList<AudioSecond*> s_data; /*004*/
    quint32 s_dataSize;             /*004*/
    QReadWriteLock s_readLock;          /*N/A*/
    QMap<long, int> s_graphs; /* length -> refCount */
    int s_graphPointingTo;
public:
    friend class AudioTrack;
    AudioContainer()
      : zero(0.0f)
      , sampleRate(live::audio::sampleRate())
      , s_data()
      , s_dataSize(0)
      , s_readLock(QReadWriteLock::NonRecursive)
      , s_graphs()
      , s_graphPointingTo(-1)
      {
    }

    void newGraph(long size) {
        if (++s_graphs[size] == 1) {
            for (int i = 0; i < s_data.size(); ++i) {
                if(s_data[i]) s_data[i]->newGraph(size);
            }
        }
    }

    void deleteGraph(long size) {
        if (--s_graphs[size] == 0) {
            for (int i = 0; i < s_data.size(); ++i) {
                if(s_data[i]) s_data[i]->deleteGraph(size);
            }
        }
    }

    void regSecond(AudioSecond* s) {
        for (QMap<long, int>::iterator it = s_graphs.begin(); it != s_graphs.end(); ++it) {
            for (int i = 0; i < it.value(); ++i) {
                s->newGraph(it.key());
            }
        }
    }

    void pointGraph(long frame) {
        if (int(frame/sampleRate) < s_data.size()) {
            s_graphPointingTo = (int)(frame/sampleRate);
            if(s_data[s_graphPointingTo]) s_data[s_graphPointingTo]->pointGraph(frame%sampleRate);
        }
    }

    void appendGraph(long frames) {
        while (s_graphPointingTo != -1 && s_graphPointingTo < s_data.size() && s_data[s_graphPointingTo]) {
            int fb = frames - s_data[s_graphPointingTo]->framesRemainingInGraph();
            s_data[s_graphPointingTo]->appendGraph(qMin(frames, s_data[s_graphPointingTo]->framesRemainingInGraph()));
            if (fb > 0) {
                frames = fb;
                if (s_graphPointingTo + 1 < s_data.size() && s_data[s_graphPointingTo + 1])
                    s_data[++s_graphPointingTo]->pointGraph(0);
                else {
                    s_graphPointingTo = -1; // this is usually transiant.
                    return;
                }
            } else {
                return;
            }
        }
    }

    AudioGraph* currentGraph(long frames) {
        if (s_graphPointingTo != -1 && s_graphPointingTo < s_data.size() && s_data[s_graphPointingTo])
            return s_data[s_graphPointingTo]->graphForFrames(frames);
        return 0;
    }

    AudioGraph* graphForPos(long frames, long pos) {
        if (pos/live::audio::sampleRate() >= 0 && pos/live::audio::sampleRate() < s_data.size() && s_data[pos/live::audio::sampleRate()])
            return s_data[pos/live::audio::sampleRate()]->graphForFrames(frames);
        return 0;
    }

    ~AudioContainer()
    {
        clear(1);
        s_dataSize=0;
    }

    void setData(const quint32&frame,const float&data)
    {
        lthread::assertAudio();
        if(data == zero)
        {
            return;
        }

        for(quint32 i=s_data.size()-1;i<=frame/sampleRate;i++)
        {
            s_data.push_back(0);
            s_dataSize=s_data.size();
        }

        if(!s_data[(int)(frame/sampleRate)])
        {
            s_data[(int)(frame/sampleRate)]=AudioSecondBank::singleton->buySecond((frame/sampleRate)*sampleRate);
            regSecond(s_data[(int)(frame/sampleRate)]);
        }

        (*s_data[(int)(frame/sampleRate)])[(int)frame]=data;
        (*s_data[(int)(frame/sampleRate)]).updateGraph(frame);
    }

    const float& getData(const int&frame)
    {
        if(s_dataSize<=frame/sampleRate||!s_data[(int)(frame/sampleRate)])
        {
            return zero;
        }
        else
        {
            return (*s_data[(int)(frame/sampleRate)])[frame];
        }
    }

    //The return is the count of data returned through "data". There may be more
    //if called for the next frame.
    //By default, if no data exists(i.e., it is all null), data will be returned as
    //a null pointer. If instead, data should be created, forceCreation should be true.
    //Remember to set the graph position, and to append graph after use.
    int getRawPointer(const quint32&frame,float*& data,bool forceCreation=0, bool enforceAudio = 1)
    {
        if (enforceAudio)
            lthread::assertAudio();
        sampleRate=audio::sampleRate();
        if((s_dataSize<=frame/sampleRate||!s_data[(int)frame/sampleRate])&&!forceCreation)
        {
            data=0;
            return (int)((frame/sampleRate)*sampleRate+sampleRate-frame);
        }
        else if(s_dataSize<=frame/sampleRate)
        {
            for(long i=s_data.size()-1;i<=(long)frame/(long)sampleRate;i++)
            {
                s_data.push_back(0);
                s_dataSize=s_data.size();
            }
        }

        if(!s_data[(int)frame/sampleRate]) {
            s_data[(int)(frame/sampleRate)]=AudioSecondBank::singleton->buySecond((frame/sampleRate)*sampleRate);
            regSecond(s_data[(int)(frame/sampleRate)]);
        }

        int id=(int)(frame/sampleRate);
        data=&s_data[id]->s_data[frame-s_data[id]->s_sampleOffset];
        return (int)(s_data[id]->s_sampleOffset+sampleRate-frame);
    }

    int getConstPointer(const quint32&frame,const float*& data) const
    {
        return const_cast<AudioContainer*>(this)->getRawPointer(frame, const_cast<float*&>(data), false, false);
    }

    class AudioDataDestroyer {
    public:
        AudioSecond* s_s;
        QReadWriteLock* s_l;
        AudioDataDestroyer(AudioSecond* s, QReadWriteLock* l) : s_s(s), s_l(l) {}
        void run() { if(s_l) s_l->lockForWrite(); delete s_s; if(s_l) s_l->unlock(); delete this; }
    };

    void clear(bool dying=0);

    float length() const
    {
        float ret = (float) s_data.size();
        int i;
        for(i = audio::sampleRate() - 1;i >= 0; --i) {
            if (s_data.back()->s_data[i]!=0.0f) break; // FIXME
        }
        ret -= float(audio::sampleRate() - i)/float(audio::sampleRate());
        return ret;
    }

    void lock() {
        s_readLock.lockForRead();
    }

    void unlock() {
        s_readLock.unlock();
    }

    static AudioContainer* load(const QByteArray&);
    QByteArray save();
};

}

#endif // AUDIOSECOND_H
